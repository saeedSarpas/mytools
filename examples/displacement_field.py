"""displacement_field.py"""

from __future__ import print_function
import numpy as np
import os

from ..visualization.myplot import MyPlot
from ..visualization.mycolordict import primarycolors


class DisplacementField(object):
    """Plotting displacement field for a portion of ICs generated by
    displacement_field.c file
    """

    def __init__(self, paths, resolutions, box_length, vel_paths=None):
        """Initializing displacement field module by loading files"""
        if len(paths) != len(resolutions):
            print("The length of the paths and resolutions array should be"
                  " the same")
            exit()

        if vel_paths is not None and len(vel_paths) != len(resolutions):
            print("The length of the vel_paths and resolutions array should be"
                  " the same")
            exit()


        self.paths = paths
        self.vel_paths = vel_paths
        self.resolutions = resolutions
        self.box_length = box_length

        self.data = {}
        self.dtype = [
            ("id", np.int),
            ("x", np.float),
            ("y", np.float),
            ("z", np.float)]

        for path in paths:
            self.data[path] = np.genfromtxt(path, dtype=self.dtype)

        if vel_paths is not None:
            self.vel_data = {}
            self.vel_dtype = [
                ("id", np.int),
                ("vx", np.float),
                ("vy", np.float),
                ("vz", np.float)]

            for vel_path in vel_paths:
                self.vel_data[vel_path] = np.genfromtxt(vel_path,
                                                        dtype=self.vel_dtype)

    def plot(self):
        """Plotting the displacement of the particles from their pre-initial
        positions
        """

        min_id = np.min(self.data[self.paths[0]]['id'])
        max_id = np.max(self.data[self.paths[0]]['id'])

        min_pos = _get_init_pos(min_id, self.resolutions[0], self.box_length)
        max_pos = _get_init_pos(max_id, self.resolutions[0], self.box_length)

        pos_colors = primarycolors('RAINBOW')
        vel_colors = primarycolors('RAINBOW')

        xmin = min_pos[1] - 0.005 * self.box_length
        xmax = max_pos[1] + 0.005 * self.box_length
        ymin = min_pos[2] - 0.005 * self.box_length
        ymax = max_pos[2] + 0.005 * self.box_length

        kws = {
            "xlabel": r"y [$Mpc/h$]",
            "ylabel": r"z [$Mpc/h$]",
            "xmin": xmin,
            "xmax": xmax,
            "ymin": ymin,
            "ymax": ymax,
            "silent": True
        }

        myplot = MyPlot(aspect=1.0)
        axes = myplot.new2daxes()

        for path, res in zip(self.paths, self.resolutions):
            data = self.data[path]

            kws['color'] = pos_colors.next()

            for disp in data:
                init_pos = _get_init_pos(disp['id'], res, self.box_length)
                myplot.arrow({
                    'init': (init_pos[1], init_pos[2]),
                    'final': (disp['y'], disp['z'])
                }, ax=axes, **dict(kws))

            myplot.save(os.path.splitext(path)[0] + ".eps")
            myplot.plt.cla()

        if self.vel_paths is None:
            return

        for path, vel_path, res in zip(
                self.data, self.vel_paths, self.resolutions):
            data = self.data[path]
            vel_data = self.vel_data[vel_path]

            mp = MyPlot(aspect=1.0)
            kws['color'] = vel_colors.next()

            for pos, vel in zip(data, vel_data):
                if pos['id'] != vel['id']:
                    print("The order of velocity and positions files are"
                          " not the same")
                    exit()

                mp.arrow({
                    'init': (pos['y'], pos['z']),
                    'final': (pos['y'] + vel['vy'],
                              pos['z'] + vel['vz'])
                }, ax=axes, **dict(kws))

            # Velocity length scale
            mp.arrow({
                'init': (xmax - 1.25, ymin + 0.3),
                'final': (xmax - 0.75, ymin + 0.3)
            }, ax=axes, **dict(kws))

            axes.annotate(r"$500 m/s$", xy=(xmax - 1.2, ymin + 0.15),
                          color=kws['color'], fontsize=10)

            myplot.save(os.path.splitext(vel_path)[0] + ".eps")
            myplot.plt.cla()


def _get_init_pos(index, res, box_len):
    """Calculating the physical position of a given grid index"""

    idx = int(index / (res**2))
    idy = int((index - (idx * res**2)) / res)
    idz = index - (idx * res**2) - (idy * res)

    pos = [0.0] * 3

    grid_len = float(box_len) / res

    pos[0] = idx * grid_len + (grid_len / 2)
    pos[1] = idy * grid_len + (grid_len / 2)
    pos[2] = idz * grid_len + (grid_len / 2)

    return pos
